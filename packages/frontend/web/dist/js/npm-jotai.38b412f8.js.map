{"version":3,"file":"js/npm-jotai.38b412f8.js","mappings":"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","sources":["webpack://@affine/web/../../../node_modules/jotai/esm/react.mjs","webpack://@affine/web/../../../node_modules/jotai/esm/react/utils.mjs","webpack://@affine/web/../../../node_modules/jotai/esm/vanilla.mjs","webpack://@affine/web/../../../node_modules/jotai/esm/vanilla/utils.mjs"],"sourcesContent":["'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(\n  void 0\n);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    promise.status = \"pending\";\n    promise.then(\n      (v) => {\n        promise.status = \"fulfilled\";\n        promise.value = v;\n      },\n      (e) => {\n        promise.status = \"rejected\";\n        promise.reason = e;\n      }\n    );\n    throw promise;\n  }\n});\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  return isPromiseLike(value) ? use(value) : value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n","'use client';\nimport { useCallback, useMemo } from 'react';\nimport { useSetAtom, useAtom, useStore } from 'jotai/react';\nimport { RESET } from 'jotai/vanilla/utils';\nimport { atom } from 'jotai/vanilla';\n\nfunction useResetAtom(anAtom, options) {\n  const setAtom = useSetAtom(anAtom, options);\n  const resetAtom = useCallback(() => setAtom(RESET), [setAtom]);\n  return resetAtom;\n}\n\nfunction useReducerAtom(anAtom, reducer, options) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] useReducerAtom is deprecated and will be removed in the future. Please create your own version using the recipe. https://github.com/pmndrs/jotai/pull/2467\"\n    );\n  }\n  const [state, setState] = useAtom(anAtom, options);\n  const dispatch = useCallback(\n    (action) => {\n      setState((prev) => reducer(prev, action));\n    },\n    [setState, reducer]\n  );\n  return [state, dispatch];\n}\n\nfunction useAtomCallback(callback, options) {\n  const anAtom = useMemo(\n    () => atom(null, (get, set, ...args) => callback(get, set, ...args)),\n    [callback]\n  );\n  return useSetAtom(anAtom, options);\n}\n\nconst hydratedMap = /* @__PURE__ */ new WeakMap();\nfunction useHydrateAtoms(values, options) {\n  const store = useStore(options);\n  const hydratedSet = getHydratedSet(store);\n  for (const [atom, value] of values) {\n    if (!hydratedSet.has(atom) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {\n      hydratedSet.add(atom);\n      store.set(atom, value);\n    }\n  }\n}\nconst getHydratedSet = (store) => {\n  let hydratedSet = hydratedMap.get(store);\n  if (!hydratedSet) {\n    hydratedSet = /* @__PURE__ */ new WeakSet();\n    hydratedMap.set(store, hydratedSet);\n  }\n  return hydratedSet;\n};\n\nexport { useAtomCallback, useHydrateAtoms, useReducerAtom, useResetAtom };\n","let keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst CONTINUE_PROMISE = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"CONTINUE_PROMISE\" : \"\"\n);\nconst PENDING = \"pending\";\nconst FULFILLED = \"fulfilled\";\nconst REJECTED = \"rejected\";\nconst isContinuablePromise = (promise) => typeof promise === \"object\" && promise !== null && CONTINUE_PROMISE in promise;\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise, abort, complete) => {\n  if (!continuablePromiseMap.has(promise)) {\n    let continuePromise;\n    const p = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          p.status = FULFILLED;\n          p.value = v;\n          resolve(v);\n          complete();\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          p.status = REJECTED;\n          p.reason = e;\n          reject(e);\n          complete();\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      continuePromise = (nextPromise, nextAbort) => {\n        if (nextPromise) {\n          continuablePromiseMap.set(nextPromise, p);\n          curr = nextPromise;\n          nextPromise.then(onFulfilled(nextPromise), onRejected(nextPromise));\n          abort();\n          abort = nextAbort;\n        }\n      };\n    });\n    p.status = PENDING;\n    p[CONTINUE_PROMISE] = continuePromise;\n    continuablePromiseMap.set(promise, p);\n  }\n  return continuablePromiseMap.get(promise);\n};\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst getPendingContinuablePromise = (atomState) => {\n  const value = atomState.v;\n  if (isContinuablePromise(value) && value.status === PENDING) {\n    return value;\n  }\n  return null;\n};\nconst addPendingContinuablePromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst createPending = () => [/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set()];\nconst addPendingAtom = (pending, atom, atomState) => {\n  if (!pending[0].has(atom)) {\n    pending[0].set(atom, /* @__PURE__ */ new Set());\n  }\n  pending[1].set(atom, atomState);\n};\nconst addPendingDependent = (pending, atom, dependent) => {\n  const dependents = pending[0].get(atom);\n  if (dependents) {\n    dependents.add(dependent);\n  }\n};\nconst getPendingDependents = (pending, atom) => pending[0].get(atom);\nconst addPendingFunction = (pending, fn) => {\n  pending[2].add(fn);\n};\nconst flushPending = (pending) => {\n  while (pending[1].size || pending[2].size) {\n    pending[0].clear();\n    const atomStates = new Set(pending[1].values());\n    pending[1].clear();\n    const functions = new Set(pending[2]);\n    pending[2].clear();\n    atomStates.forEach((atomState) => {\n      var _a;\n      return (_a = atomState.m) == null ? void 0 : _a.l.forEach((l) => l());\n    });\n    functions.forEach((fn) => fn());\n  }\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  let debugMountedAtoms;\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    debugMountedAtoms = /* @__PURE__ */ new Set();\n  }\n  const getAtomState = (atom) => {\n    let atomState = atomStateMap.get(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      atomStateMap.set(atom, atomState);\n    }\n    return atomState;\n  };\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise, abortPromise = () => {\n  }, completePromise = () => {\n  }) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = getPendingContinuablePromise(atomState);\n    if (isPromiseLike(valueOrPromise)) {\n      if (pendingPromise) {\n        if (pendingPromise !== valueOrPromise) {\n          pendingPromise[CONTINUE_PROMISE](valueOrPromise, abortPromise);\n          ++atomState.n;\n        }\n      } else {\n        const continuablePromise = createContinuablePromise(\n          valueOrPromise,\n          abortPromise,\n          completePromise\n        );\n        if (continuablePromise.status === PENDING) {\n          for (const a of atomState.d.keys()) {\n            const aState = getAtomState(a);\n            addPendingContinuablePromiseToDependency(\n              atom,\n              continuablePromise,\n              aState\n            );\n          }\n        }\n        atomState.v = continuablePromise;\n        delete atomState.e;\n      }\n    } else {\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](\n          Promise.resolve(valueOrPromise),\n          abortPromise\n        );\n      }\n      atomState.v = valueOrPromise;\n      delete atomState.e;\n    }\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n    }\n  };\n  const addDependency = (pending, atom, a, aState) => {\n    var _a;\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && a === atom) {\n      throw new Error(\"[Bug] atom cannot depend on itself\");\n    }\n    const atomState = getAtomState(atom);\n    atomState.d.set(a, aState.n);\n    const continuablePromise = getPendingContinuablePromise(atomState);\n    if (continuablePromise) {\n      addPendingContinuablePromiseToDependency(atom, continuablePromise, aState);\n    }\n    (_a = aState.m) == null ? void 0 : _a.t.add(atom);\n    if (pending) {\n      addPendingDependent(pending, a, atom);\n    }\n  };\n  const readAtomState = (pending, atom, force) => {\n    const atomState = getAtomState(atom);\n    if (!(force == null ? void 0 : force(atom)) && isAtomStateInitialized(atomState)) {\n      if (atomState.m) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(pending, a, force).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = getAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(pending, a, force);\n      if (isSync) {\n        addDependency(pending, atom, a, aState);\n      } else {\n        const pending2 = createPending();\n        addDependency(pending2, atom, a, aState);\n        mountDependencies(pending2, atom, atomState);\n        flushPending(pending2);\n      }\n      return returnAtomValue(aState);\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atom.read(getter, options);\n      setAtomStateValueOrPromise(\n        atom,\n        atomState,\n        valueOrPromise,\n        () => controller == null ? void 0 : controller.abort(),\n        () => {\n          if (atomState.m) {\n            const pending2 = createPending();\n            mountDependencies(pending2, atom, atomState);\n            flushPending(pending2);\n          }\n        }\n      );\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(void 0, atom));\n  const recomputeDependents = (pending, atom) => {\n    const getDependents = (a) => {\n      var _a, _b;\n      const aState = getAtomState(a);\n      const dependents = new Set((_a = aState.m) == null ? void 0 : _a.t);\n      for (const atomWithPendingContinuablePromise of aState.p) {\n        dependents.add(atomWithPendingContinuablePromise);\n      }\n      (_b = getPendingDependents(pending, a)) == null ? void 0 : _b.forEach((dependent) => {\n        dependents.add(dependent);\n      });\n      return dependents;\n    };\n    const topsortedAtoms = [];\n    const markedAtoms = /* @__PURE__ */ new Set();\n    const visit = (n) => {\n      if (markedAtoms.has(n)) {\n        return;\n      }\n      markedAtoms.add(n);\n      for (const m of getDependents(n)) {\n        if (n !== m) {\n          visit(m);\n        }\n      }\n      topsortedAtoms.push(n);\n    };\n    visit(atom);\n    const changedAtoms = /* @__PURE__ */ new Set([atom]);\n    const isMarked = (a) => markedAtoms.has(a);\n    for (let i = topsortedAtoms.length - 1; i >= 0; --i) {\n      const a = topsortedAtoms[i];\n      const aState = getAtomState(a);\n      const prevEpochNumber = aState.n;\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(pending, a, isMarked);\n        mountDependencies(pending, a, aState);\n        if (prevEpochNumber !== aState.n) {\n          addPendingAtom(pending, a, aState);\n          changedAtoms.add(a);\n        }\n      }\n      markedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (pending, atom, ...args) => {\n    const getter = (a) => returnAtomValue(readAtomState(pending, a));\n    const setter = (a, ...args2) => {\n      let r;\n      if (isSelfAtom(atom, a)) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const aState = getAtomState(a);\n        const hasPrevValue = \"v\" in aState;\n        const prevValue = aState.v;\n        const v = args2[0];\n        setAtomStateValueOrPromise(a, aState, v);\n        mountDependencies(pending, a, aState);\n        if (!hasPrevValue || !Object.is(prevValue, aState.v)) {\n          addPendingAtom(pending, a, aState);\n          recomputeDependents(pending, a);\n        }\n      } else {\n        r = writeAtomState(pending, a, ...args2);\n      }\n      flushPending(pending);\n      return r;\n    };\n    const result = atom.write(getter, setter, ...args);\n    return result;\n  };\n  const writeAtom = (atom, ...args) => {\n    const pending = createPending();\n    const result = writeAtomState(pending, atom, ...args);\n    flushPending(pending);\n    return result;\n  };\n  const mountDependencies = (pending, atom, atomState) => {\n    if (atomState.m && !getPendingContinuablePromise(atomState)) {\n      for (const a of atomState.d.keys()) {\n        if (!atomState.m.d.has(a)) {\n          const aMounted = mountAtom(pending, a);\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(pending, a);\n          aMounted == null ? void 0 : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (!atomState.m) {\n      readAtomState(pending, atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(pending, a);\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        debugMountedAtoms.add(atom);\n      }\n      if (isActuallyWritableAtom(atom) && atom.onMount) {\n        const mounted = atomState.m;\n        const { onMount } = atom;\n        addPendingFunction(pending, () => {\n          const onUnmount = onMount(\n            (...args) => writeAtomState(pending, atom, ...args)\n          );\n          if (onUnmount) {\n            mounted.u = onUnmount;\n          }\n        });\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (pending, atom) => {\n    const atomState = getAtomState(atom);\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\n      var _a;\n      return (_a = getAtomState(a).m) == null ? void 0 : _a.d.has(atom);\n    })) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        addPendingFunction(pending, onUnmount);\n      }\n      delete atomState.m;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        debugMountedAtoms.delete(atom);\n      }\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(pending, a);\n        aMounted == null ? void 0 : aMounted.t.delete(atom);\n      }\n      const pendingPromise = getPendingContinuablePromise(atomState);\n      if (pendingPromise) {\n        pendingPromise[CONTINUE_PROMISE](void 0, () => {\n        });\n      }\n      return void 0;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const pending = createPending();\n    const mounted = mountAtom(pending, atom);\n    flushPending(pending);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      const pending2 = createPending();\n      unmountAtom(pending2, atom);\n      flushPending(pending2);\n    };\n  };\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    const devStore = {\n      // store dev methods (these are tentative and subject to change without notice)\n      dev4_get_internal_weak_map: () => atomStateMap,\n      dev4_get_mounted_atoms: () => debugMountedAtoms,\n      dev4_restore_atoms: (values) => {\n        const pending = createPending();\n        for (const [atom, value] of values) {\n          if (hasInitialValue(atom)) {\n            const atomState = getAtomState(atom);\n            const hasPrevValue = \"v\" in atomState;\n            const prevValue = atomState.v;\n            setAtomStateValueOrPromise(atom, atomState, value);\n            mountDependencies(pending, atom, atomState);\n            if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n              addPendingAtom(pending, atom, atomState);\n              recomputeDependents(pending, atom);\n            }\n          }\n        }\n        flushPending(pending);\n      }\n    };\n    Object.assign(store, devStore);\n  }\n  return store;\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\nexport { atom, createStore, getDefaultStore };\n","import { atom } from 'jotai/vanilla';\n\nconst RESET = Symbol(\n  (import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" ? \"RESET\" : \"\"\n);\n\nfunction atomWithReset(initialValue) {\n  const anAtom = atom(\n    initialValue,\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(anAtom)) : update;\n      set(anAtom, nextValue === RESET ? initialValue : nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithReducer(initialValue, reducer) {\n  return atom(initialValue, function(get, set, action) {\n    set(this, reducer(get(this), action));\n  });\n}\n\nfunction atomFamily(initializeAtom, areEqual) {\n  let shouldRemove = null;\n  const atoms = /* @__PURE__ */ new Map();\n  const createAtom = (param) => {\n    let item;\n    if (areEqual === void 0) {\n      item = atoms.get(param);\n    } else {\n      for (const [key, value] of atoms) {\n        if (areEqual(key, param)) {\n          item = value;\n          break;\n        }\n      }\n    }\n    if (item !== void 0) {\n      if (shouldRemove == null ? void 0 : shouldRemove(item[1], param)) {\n        createAtom.remove(param);\n      } else {\n        return item[0];\n      }\n    }\n    const newAtom = initializeAtom(param);\n    atoms.set(param, [newAtom, Date.now()]);\n    return newAtom;\n  };\n  createAtom.remove = (param) => {\n    if (areEqual === void 0) {\n      atoms.delete(param);\n    } else {\n      for (const [key] of atoms) {\n        if (areEqual(key, param)) {\n          atoms.delete(key);\n          break;\n        }\n      }\n    }\n  };\n  createAtom.setShouldRemove = (fn) => {\n    shouldRemove = fn;\n    if (!shouldRemove) return;\n    for (const [key, value] of atoms) {\n      if (shouldRemove(value[1], key)) {\n        atoms.delete(key);\n      }\n    }\n  };\n  return createAtom;\n}\n\nconst getCached$2 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$3 = /* @__PURE__ */ new WeakMap();\nconst memo3 = (create, dep1, dep2, dep3) => {\n  const cache2 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache1$3, dep1);\n  const cache3 = getCached$2(() => /* @__PURE__ */ new WeakMap(), cache2, dep2);\n  return getCached$2(create, cache3, dep3);\n};\nfunction selectAtom(anAtom, selector, equalityFn = Object.is) {\n  return memo3(\n    () => {\n      const EMPTY = Symbol();\n      const selectValue = ([value, prevSlice]) => {\n        if (prevSlice === EMPTY) {\n          return selector(value);\n        }\n        const slice = selector(value, prevSlice);\n        return equalityFn(prevSlice, slice) ? prevSlice : slice;\n      };\n      const derivedAtom = atom((get) => {\n        const prev = get(derivedAtom);\n        const value = get(anAtom);\n        return selectValue([value, prev]);\n      });\n      derivedAtom.init = EMPTY;\n      return derivedAtom;\n    },\n    anAtom,\n    selector,\n    equalityFn\n  );\n}\n\nconst frozenAtoms = /* @__PURE__ */ new WeakSet();\nconst deepFreeze = (obj) => {\n  if (typeof obj !== \"object\" || obj === null) return;\n  Object.freeze(obj);\n  const propNames = Object.getOwnPropertyNames(obj);\n  for (const name of propNames) {\n    const value = obj[name];\n    deepFreeze(value);\n  }\n  return obj;\n};\nfunction freezeAtom(anAtom) {\n  if (frozenAtoms.has(anAtom)) {\n    return anAtom;\n  }\n  frozenAtoms.add(anAtom);\n  const origRead = anAtom.read;\n  anAtom.read = function(get, options) {\n    return deepFreeze(origRead.call(this, get, options));\n  };\n  if (\"write\" in anAtom) {\n    const origWrite = anAtom.write;\n    anAtom.write = function(get, set, ...args) {\n      return origWrite.call(\n        this,\n        get,\n        (...setArgs) => {\n          if (setArgs[0] === anAtom) {\n            setArgs[1] = deepFreeze(setArgs[1]);\n          }\n          return set(...setArgs);\n        },\n        ...args\n      );\n    };\n  }\n  return anAtom;\n}\nfunction freezeAtomCreator(createAtom) {\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    console.warn(\n      \"[DEPRECATED] freezeAtomCreator is deprecated, define it on users end\"\n    );\n  }\n  return (...args) => freezeAtom(createAtom(...args));\n}\n\nconst getCached$1 = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1$2 = /* @__PURE__ */ new WeakMap();\nconst memo2$1 = (create, dep1, dep2) => {\n  const cache2 = getCached$1(() => /* @__PURE__ */ new WeakMap(), cache1$2, dep1);\n  return getCached$1(create, cache2, dep2);\n};\nconst cacheKeyForEmptyKeyExtractor = {};\nconst isWritable = (atom2) => !!atom2.write;\nconst isFunction = (x) => typeof x === \"function\";\nfunction splitAtom(arrAtom, keyExtractor) {\n  return memo2$1(\n    () => {\n      const mappingCache = /* @__PURE__ */ new WeakMap();\n      const getMapping = (arr, prev) => {\n        let mapping = mappingCache.get(arr);\n        if (mapping) {\n          return mapping;\n        }\n        const prevMapping = prev && mappingCache.get(prev);\n        const atomList = [];\n        const keyList = [];\n        arr.forEach((item, index) => {\n          const key = keyExtractor ? keyExtractor(item) : index;\n          keyList[index] = key;\n          const cachedAtom = prevMapping && prevMapping.atomList[prevMapping.keyList.indexOf(key)];\n          if (cachedAtom) {\n            atomList[index] = cachedAtom;\n            return;\n          }\n          const read = (get) => {\n            const prev2 = get(mappingAtom);\n            const currArr = get(arrAtom);\n            const mapping2 = getMapping(currArr, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= currArr.length) {\n              const prevItem = arr[getMapping(arr).keyList.indexOf(key)];\n              if (prevItem) {\n                return prevItem;\n              }\n              throw new Error(\"splitAtom: index out of bounds for read\");\n            }\n            return currArr[index2];\n          };\n          const write = (get, set, update) => {\n            const prev2 = get(mappingAtom);\n            const arr2 = get(arrAtom);\n            const mapping2 = getMapping(arr2, prev2 == null ? void 0 : prev2.arr);\n            const index2 = mapping2.keyList.indexOf(key);\n            if (index2 < 0 || index2 >= arr2.length) {\n              throw new Error(\"splitAtom: index out of bounds for write\");\n            }\n            const nextItem = isFunction(update) ? update(arr2[index2]) : update;\n            if (!Object.is(arr2[index2], nextItem)) {\n              set(arrAtom, [\n                ...arr2.slice(0, index2),\n                nextItem,\n                ...arr2.slice(index2 + 1)\n              ]);\n            }\n          };\n          atomList[index] = isWritable(arrAtom) ? atom(read, write) : atom(read);\n        });\n        if (prevMapping && prevMapping.keyList.length === keyList.length && prevMapping.keyList.every((x, i) => x === keyList[i])) {\n          mapping = prevMapping;\n        } else {\n          mapping = { arr, atomList, keyList };\n        }\n        mappingCache.set(arr, mapping);\n        return mapping;\n      };\n      const mappingAtom = atom((get) => {\n        const prev = get(mappingAtom);\n        const arr = get(arrAtom);\n        const mapping = getMapping(arr, prev == null ? void 0 : prev.arr);\n        return mapping;\n      });\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        mappingAtom.debugPrivate = true;\n      }\n      mappingAtom.init = void 0;\n      const splittedAtom = isWritable(arrAtom) ? atom(\n        (get) => get(mappingAtom).atomList,\n        (get, set, action) => {\n          switch (action.type) {\n            case \"remove\": {\n              const index = get(splittedAtom).indexOf(action.atom);\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  ...arr.slice(index + 1)\n                ]);\n              }\n              break;\n            }\n            case \"insert\": {\n              const index = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index >= 0) {\n                const arr = get(arrAtom);\n                set(arrAtom, [\n                  ...arr.slice(0, index),\n                  action.value,\n                  ...arr.slice(index)\n                ]);\n              }\n              break;\n            }\n            case \"move\": {\n              const index1 = get(splittedAtom).indexOf(action.atom);\n              const index2 = action.before ? get(splittedAtom).indexOf(action.before) : get(splittedAtom).length;\n              if (index1 >= 0 && index2 >= 0) {\n                const arr = get(arrAtom);\n                if (index1 < index2) {\n                  set(arrAtom, [\n                    ...arr.slice(0, index1),\n                    ...arr.slice(index1 + 1, index2),\n                    arr[index1],\n                    ...arr.slice(index2)\n                  ]);\n                } else {\n                  set(arrAtom, [\n                    ...arr.slice(0, index2),\n                    arr[index1],\n                    ...arr.slice(index2, index1),\n                    ...arr.slice(index1 + 1)\n                  ]);\n                }\n              }\n              break;\n            }\n          }\n        }\n      ) : atom((get) => get(mappingAtom).atomList);\n      return splittedAtom;\n    },\n    arrAtom,\n    keyExtractor || cacheKeyForEmptyKeyExtractor\n  );\n}\n\nfunction atomWithDefault(getDefault) {\n  const EMPTY = Symbol();\n  const overwrittenAtom = atom(EMPTY);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    overwrittenAtom.debugPrivate = true;\n  }\n  const anAtom = atom(\n    (get, options) => {\n      const overwritten = get(overwrittenAtom);\n      if (overwritten !== EMPTY) {\n        return overwritten;\n      }\n      return getDefault(get, options);\n    },\n    (get, set, update) => {\n      if (update === RESET) {\n        set(overwrittenAtom, EMPTY);\n      } else if (typeof update === \"function\") {\n        const prevValue = get(anAtom);\n        set(overwrittenAtom, update(prevValue));\n      } else {\n        set(overwrittenAtom, update);\n      }\n    }\n  );\n  return anAtom;\n}\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nfunction withStorageValidator(validator) {\n  return (unknownStorage) => {\n    const storage = {\n      ...unknownStorage,\n      getItem: (key, initialValue) => {\n        const validate = (value2) => {\n          if (!validator(value2)) {\n            return initialValue;\n          }\n          return value2;\n        };\n        const value = unknownStorage.getItem(key, initialValue);\n        if (isPromiseLike(value)) {\n          return value.then(validate);\n        }\n        return validate(value);\n      }\n    };\n    return storage;\n  };\n}\nfunction createJSONStorage(getStringStorage = () => {\n  try {\n    return window.localStorage;\n  } catch (e) {\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      if (typeof window !== \"undefined\") {\n        console.warn(e);\n      }\n    }\n    return void 0;\n  }\n}, options) {\n  var _a;\n  let lastStr;\n  let lastValue;\n  const storage = {\n    getItem: (key, initialValue) => {\n      var _a2, _b;\n      const parse = (str2) => {\n        str2 = str2 || \"\";\n        if (lastStr !== str2) {\n          try {\n            lastValue = JSON.parse(str2, options == null ? void 0 : options.reviver);\n          } catch (e) {\n            return initialValue;\n          }\n          lastStr = str2;\n        }\n        return lastValue;\n      };\n      const str = (_b = (_a2 = getStringStorage()) == null ? void 0 : _a2.getItem(key)) != null ? _b : null;\n      if (isPromiseLike(str)) {\n        return str.then(parse);\n      }\n      return parse(str);\n    },\n    setItem: (key, newValue) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.setItem(\n        key,\n        JSON.stringify(newValue, options == null ? void 0 : options.replacer)\n      );\n    },\n    removeItem: (key) => {\n      var _a2;\n      return (_a2 = getStringStorage()) == null ? void 0 : _a2.removeItem(key);\n    }\n  };\n  const createHandleSubscribe = (subscriber2) => (key, callback, initialValue) => subscriber2(key, (v) => {\n    let newValue;\n    try {\n      newValue = JSON.parse(v || \"\");\n    } catch (e) {\n      newValue = initialValue;\n    }\n    callback(newValue);\n  });\n  let subscriber;\n  try {\n    subscriber = (_a = getStringStorage()) == null ? void 0 : _a.subscribe;\n  } catch (e) {\n  }\n  if (!subscriber && typeof window !== \"undefined\" && typeof window.addEventListener === \"function\" && window.Storage) {\n    subscriber = (key, callback) => {\n      if (!(getStringStorage() instanceof window.Storage)) {\n        return () => {\n        };\n      }\n      const storageEventCallback = (e) => {\n        if (e.storageArea === getStringStorage() && e.key === key) {\n          callback(e.newValue);\n        }\n      };\n      window.addEventListener(\"storage\", storageEventCallback);\n      return () => {\n        window.removeEventListener(\"storage\", storageEventCallback);\n      };\n    };\n  }\n  if (subscriber) {\n    storage.subscribe = createHandleSubscribe(subscriber);\n  }\n  return storage;\n}\nconst defaultStorage = createJSONStorage();\nfunction atomWithStorage(key, initialValue, storage = defaultStorage, options) {\n  const getOnInit = options == null ? void 0 : options.getOnInit;\n  const baseAtom = atom(\n    getOnInit ? storage.getItem(key, initialValue) : initialValue\n  );\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    baseAtom.debugPrivate = true;\n  }\n  baseAtom.onMount = (setAtom) => {\n    setAtom(storage.getItem(key, initialValue));\n    let unsub;\n    if (storage.subscribe) {\n      unsub = storage.subscribe(key, setAtom, initialValue);\n    }\n    return unsub;\n  };\n  const anAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, update) => {\n      const nextValue = typeof update === \"function\" ? update(get(baseAtom)) : update;\n      if (nextValue === RESET) {\n        set(baseAtom, initialValue);\n        return storage.removeItem(key);\n      }\n      if (nextValue instanceof Promise) {\n        return nextValue.then((resolvedValue) => {\n          set(baseAtom, resolvedValue);\n          return storage.setItem(key, resolvedValue);\n        });\n      }\n      set(baseAtom, nextValue);\n      return storage.setItem(key, nextValue);\n    }\n  );\n  return anAtom;\n}\n\nfunction atomWithObservable(getObservable, options) {\n  const returnResultData = (result) => {\n    if (\"e\" in result) {\n      throw result.e;\n    }\n    return result.d;\n  };\n  const observableResultAtom = atom((get) => {\n    var _a;\n    let observable = getObservable(get);\n    const itself = (_a = observable[Symbol.observable]) == null ? void 0 : _a.call(observable);\n    if (itself) {\n      observable = itself;\n    }\n    let resolve;\n    const makePending = () => new Promise((r) => {\n      resolve = r;\n    });\n    const initialResult = options && \"initialValue\" in options ? {\n      d: typeof options.initialValue === \"function\" ? options.initialValue() : options.initialValue\n    } : makePending();\n    let setResult;\n    let lastResult;\n    const listener = (result) => {\n      lastResult = result;\n      resolve == null ? void 0 : resolve(result);\n      setResult == null ? void 0 : setResult(result);\n    };\n    let subscription;\n    let timer;\n    const isNotMounted = () => !setResult;\n    const start = () => {\n      if (subscription) {\n        clearTimeout(timer);\n        subscription.unsubscribe();\n      }\n      subscription = observable.subscribe({\n        next: (d) => listener({ d }),\n        error: (e) => listener({ e }),\n        complete: () => {\n        }\n      });\n      if (isNotMounted() && (options == null ? void 0 : options.unstable_timeout)) {\n        timer = setTimeout(() => {\n          if (subscription) {\n            subscription.unsubscribe();\n            subscription = void 0;\n          }\n        }, options.unstable_timeout);\n      }\n    };\n    start();\n    const resultAtom = atom(lastResult || initialResult);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      resultAtom.debugPrivate = true;\n    }\n    resultAtom.onMount = (update) => {\n      setResult = update;\n      if (lastResult) {\n        update(lastResult);\n      }\n      if (subscription) {\n        clearTimeout(timer);\n      } else {\n        start();\n      }\n      return () => {\n        setResult = void 0;\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = void 0;\n        }\n      };\n    };\n    return [resultAtom, observable, makePending, start, isNotMounted];\n  });\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    observableResultAtom.debugPrivate = true;\n  }\n  const observableAtom = atom(\n    (get) => {\n      const [resultAtom] = get(observableResultAtom);\n      const result = get(resultAtom);\n      if (result instanceof Promise) {\n        return result.then(returnResultData);\n      }\n      return returnResultData(result);\n    },\n    (get, set, data) => {\n      const [resultAtom, observable, makePending, start, isNotMounted] = get(observableResultAtom);\n      if (\"next\" in observable) {\n        if (isNotMounted()) {\n          set(resultAtom, makePending());\n          start();\n        }\n        observable.next(data);\n      } else {\n        throw new Error(\"observable is not subject\");\n      }\n    }\n  );\n  return observableAtom;\n}\n\nconst cache1$1 = /* @__PURE__ */ new WeakMap();\nconst memo1 = (create, dep1) => (cache1$1.has(dep1) ? cache1$1 : cache1$1.set(dep1, create())).get(dep1);\nconst isPromise$1 = (x) => x instanceof Promise;\nconst LOADING = { state: \"loading\" };\nfunction loadable(anAtom) {\n  return memo1(() => {\n    const loadableCache = /* @__PURE__ */ new WeakMap();\n    const refreshAtom = atom(0);\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      refreshAtom.debugPrivate = true;\n    }\n    const derivedAtom = atom(\n      (get, { setSelf }) => {\n        get(refreshAtom);\n        let value;\n        try {\n          value = get(anAtom);\n        } catch (error) {\n          return { state: \"hasError\", error };\n        }\n        if (!isPromise$1(value)) {\n          return { state: \"hasData\", data: value };\n        }\n        const promise = value;\n        const cached1 = loadableCache.get(promise);\n        if (cached1) {\n          return cached1;\n        }\n        if (promise.status === \"fulfilled\") {\n          loadableCache.set(promise, { state: \"hasData\", data: promise.value });\n        } else if (promise.status === \"rejected\") {\n          loadableCache.set(promise, {\n            state: \"hasError\",\n            error: promise.reason\n          });\n        } else {\n          promise.then(\n            (data) => {\n              loadableCache.set(promise, { state: \"hasData\", data });\n            },\n            (error) => {\n              loadableCache.set(promise, { state: \"hasError\", error });\n            }\n          ).finally(setSelf);\n        }\n        const cached2 = loadableCache.get(promise);\n        if (cached2) {\n          return cached2;\n        }\n        loadableCache.set(promise, LOADING);\n        return LOADING;\n      },\n      (_get, set) => {\n        set(refreshAtom, (c) => c + 1);\n      }\n    );\n    if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n      derivedAtom.debugPrivate = true;\n    }\n    return atom((get) => get(derivedAtom));\n  }, anAtom);\n}\n\nconst getCached = (c, m, k) => (m.has(k) ? m : m.set(k, c())).get(k);\nconst cache1 = /* @__PURE__ */ new WeakMap();\nconst memo2 = (create, dep1, dep2) => {\n  const cache2 = getCached(() => /* @__PURE__ */ new WeakMap(), cache1, dep1);\n  return getCached(create, cache2, dep2);\n};\nconst isPromise = (x) => x instanceof Promise;\nconst defaultFallback = () => void 0;\nfunction unwrap(anAtom, fallback = defaultFallback) {\n  return memo2(\n    () => {\n      const promiseErrorCache = /* @__PURE__ */ new WeakMap();\n      const promiseResultCache = /* @__PURE__ */ new WeakMap();\n      const refreshAtom = atom(0);\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        refreshAtom.debugPrivate = true;\n      }\n      const promiseAndValueAtom = atom(\n        (get, { setSelf }) => {\n          get(refreshAtom);\n          const prev = get(promiseAndValueAtom);\n          const promise = get(anAtom);\n          if (!isPromise(promise)) {\n            return { v: promise };\n          }\n          if (promise !== (prev == null ? void 0 : prev.p)) {\n            if (promise.status === \"fulfilled\") {\n              promiseResultCache.set(promise, promise.value);\n            } else if (promise.status === \"rejected\") {\n              promiseErrorCache.set(promise, promise.reason);\n            } else {\n              promise.then(\n                (v) => promiseResultCache.set(promise, v),\n                (e) => promiseErrorCache.set(promise, e)\n              ).finally(setSelf);\n            }\n          }\n          if (promiseErrorCache.has(promise)) {\n            throw promiseErrorCache.get(promise);\n          }\n          if (promiseResultCache.has(promise)) {\n            return {\n              p: promise,\n              v: promiseResultCache.get(promise)\n            };\n          }\n          if (prev && \"v\" in prev) {\n            return { p: promise, f: fallback(prev.v), v: prev.v };\n          }\n          return { p: promise, f: fallback() };\n        },\n        (_get, set) => {\n          set(refreshAtom, (c) => c + 1);\n        }\n      );\n      promiseAndValueAtom.init = void 0;\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n        promiseAndValueAtom.debugPrivate = true;\n      }\n      return atom(\n        (get) => {\n          const state = get(promiseAndValueAtom);\n          if (\"f\" in state) {\n            return state.f;\n          }\n          return state.v;\n        },\n        (_get, set, ...args) => set(anAtom, ...args)\n      );\n    },\n    anAtom,\n    fallback\n  );\n}\n\nfunction atomWithRefresh(read, write) {\n  const refreshAtom = atom(0);\n  if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\") {\n    refreshAtom.debugPrivate = true;\n  }\n  return atom(\n    (get, options) => {\n      get(refreshAtom);\n      return read(get, options);\n    },\n    (get, set, ...args) => {\n      if (args.length === 0) {\n        set(refreshAtom, (c) => c + 1);\n      } else if (write) {\n        return write(get, set, ...args);\n      }\n    }\n  );\n}\n\nfunction atomWithLazy(makeInitial) {\n  const a = atom(void 0);\n  delete a.init;\n  Object.defineProperty(a, \"init\", {\n    get() {\n      return makeInitial();\n    }\n  });\n  return a;\n}\n\nexport { RESET, atomFamily, atomWithDefault, atomWithLazy, atomWithObservable, atomWithReducer, atomWithRefresh, atomWithReset, atomWithStorage, createJSONStorage, freezeAtom, freezeAtomCreator, loadable, selectAtom, splitAtom, withStorageValidator as unstable_withStorageValidator, unwrap };\n"],"names":["StoreContext","createContext","useStore","store","useContext","options","Provider","children","storeRef","useRef","current","createElement","value","isPromiseLike","x","then","use","promise","status","reason","v","e","useAtomValue","atom","valueFromReducer","storeFromReducer","atomFromReducer","rerender","useReducer","nextValue","get","is","prev","delay","useEffect","unsub","sub","setTimeout","useDebugValue","useSetAtom","useCallback","args","set","useAtom","hydratedMap","WeakMap","useHydrateAtoms","values","hydratedSet","getHydratedSet","has","dangerouslyForceHydrate","add","WeakSet","defaultStore","keyCount","read","write","key","config","toString","debugLabel","init","defaultRead","defaultWrite","arg","isSelfAtom","a","unstable_is","hasInitialValue","isActuallyWritableAtom","CONTINUE_PROMISE","Symbol","PENDING","isContinuablePromise","continuablePromiseMap","createContinuablePromise","abort","complete","continuePromise","p","Promise","resolve","reject","curr","onFulfilled","me","onRejected","nextPromise","nextAbort","isAtomStateInitialized","atomState","returnAtomValue","getPendingContinuablePromise","addPendingContinuablePromiseToDependency","dependencyAtomState","delete","createPending","Map","Set","addPendingAtom","pending","addPendingDependent","dependent","dependents","getPendingDependents","addPendingFunction","fn","flushPending","size","clear","atomStates","functions","forEach","_a","m","l","createStore","debugMountedAtoms","atomStateMap","getAtomState","d","n","setAtomStateValueOrPromise","valueOrPromise","abortPromise","completePromise","hasPrevValue","prevValue","pendingPromise","continuablePromise","keys","Object","addDependency","aState","t","readAtomState","force","controller","setSelf","Array","from","every","isSync","aState2","pending2","mountDependencies","signal","AbortController","console","warn","writeAtom","error","recomputeDependents","getDependents","_b","atomWithPendingContinuablePromise","topsortedAtoms","markedAtoms","visit","push","changedAtoms","isMarked","i","length","prevEpochNumber","hasChangedDeps","dep","writeAtomState","args2","r","result","aMounted","unmountAtom","mountAtom","onMount","mounted","onUnmount","u","some","listener","listeners","assign","dev4_get_internal_weak_map","dev4_get_mounted_atoms","dev4_restore_atoms","getDefaultStore","globalThis","__JOTAI_DEFAULT_STORE__","RESET","getCached$2","c","k","cache1$3","memo3","create","dep1","dep2","dep3","cache2","cache3","selectAtom","anAtom","selector","equalityFn","EMPTY","selectValue","prevSlice","slice","derivedAtom","defaultStorage","createJSONStorage","getStringStorage","window","localStorage","lastStr","lastValue","subscriber","storage","getItem","initialValue","_a2","parse","str2","JSON","str","setItem","newValue","stringify","removeItem","subscribe","addEventListener","Storage","callback","storageEventCallback","storageArea","removeEventListener","subscriber2","atomWithStorage","getOnInit","baseAtom","debugPrivate","setAtom","update","resolvedValue","atomWithObservable","getObservable","returnResultData","observableResultAtom","setResult","lastResult","subscription","timer","observable","itself","call","makePending","initialResult","isNotMounted","start","clearTimeout","unsubscribe","next","unstable_timeout","resultAtom","data"],"sourceRoot":""}