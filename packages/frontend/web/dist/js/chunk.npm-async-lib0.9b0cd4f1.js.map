{"version":3,"file":"js/chunk.npm-async-lib0.9b0cd4f1.js","mappings":"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","sources":["webpack://@affine/web/../../../node_modules/lib0/array.js","webpack://@affine/web/../../../node_modules/lib0/binary.js","webpack://@affine/web/../../../node_modules/lib0/buffer.js","webpack://@affine/web/../../../node_modules/lib0/decoding.js","webpack://@affine/web/../../../node_modules/lib0/encoding.js","webpack://@affine/web/../../../node_modules/lib0/environment.js","webpack://@affine/web/../../../node_modules/lib0/conditions.js","webpack://@affine/web/../../../node_modules/lib0/storage.js","webpack://@affine/web/../../../node_modules/lib0/error.js","webpack://@affine/web/../../../node_modules/lib0/function.js","webpack://@affine/web/../../../node_modules/lib0/hash/sha256.js","webpack://@affine/web/../../../node_modules/lib0/iterator.js","webpack://@affine/web/../../../node_modules/lib0/symbol.js","webpack://@affine/web/../../../node_modules/lib0/logging.common.js","webpack://@affine/web/../../../node_modules/lib0/pair.js","webpack://@affine/web/../../../node_modules/lib0/dom.js","webpack://@affine/web/../../../node_modules/lib0/logging.js","webpack://@affine/web/../../../node_modules/lib0/map.js","webpack://@affine/web/../../../node_modules/lib0/math.js","webpack://@affine/web/../../../node_modules/lib0/number.js","webpack://@affine/web/../../../node_modules/lib0/object.js","webpack://@affine/web/../../../node_modules/lib0/observable.js","webpack://@affine/web/../../../node_modules/lib0/promise.js","webpack://@affine/web/../../../node_modules/lib0/webcrypto.js","webpack://@affine/web/../../../node_modules/lib0/random.js","webpack://@affine/web/../../../node_modules/lib0/set.js","webpack://@affine/web/../../../node_modules/lib0/string.js","webpack://@affine/web/../../../node_modules/lib0/time.js"],"sourcesContent":["/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\nimport * as set from './set.js'\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nexport const unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nexport const fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nexport const isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nexport const unique = arr => from(set.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nexport const uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = set.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n\n/**\n * @template {ArrayLike<any>} ARR\n * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER\n * @param {ARR} arr\n * @param {MAPPER} mapper\n * @return {Array<MAPPER extends function(...any): infer M ? M : never>}\n */\nexport const map = (arr, mapper) => {\n  /**\n   * @type {Array<any>}\n   */\n  const res = Array(arr.length)\n  for (let i = 0; i < arr.length; i++) {\n    res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))\n  }\n  return /** @type {any} */ (res)\n}\n","/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n","/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\nimport * as string from './string.js'\nimport * as env from './environment.js'\nimport * as array from './array.js'\nimport * as math from './math.js'\nimport * as encoding from './encoding.js'\nimport * as decoding from './decoding.js'\n\n/**\n * @param {number} len\n */\nexport const createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nexport const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nexport const createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* c8 ignore start */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* c8 ignore start */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* c8 ignore next */\nexport const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node\n\n/* c8 ignore next */\nexport const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Implements base64url - see https://datatracker.ietf.org/doc/html/rfc4648#section-5\n * @param {Uint8Array} buf\n */\nexport const toBase64UrlEncoded = buf => toBase64(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '')\n\n/**\n * @param {string} base64\n */\nexport const fromBase64UrlEncoded = base64 => fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'))\n\n/**\n * Base64 is always a more efficient choice. This exists for utility purposes only.\n *\n * @param {Uint8Array} buf\n */\nexport const toHexString = buf => array.map(buf, b => b.toString(16).padStart(2, '0')).join('')\n\n/**\n * Note: This function expects that the hex doesn't start with 0x..\n *\n * @param {string} hex\n */\nexport const fromHexString = hex => {\n  const hlen = hex.length\n  const buf = new Uint8Array(math.ceil(hlen / 2))\n  for (let i = 0; i < hlen; i += 2) {\n    buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16)\n  }\n  return buf\n}\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nexport const copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nexport const encodeAny = data =>\n  encoding.encode(encoder => encoding.writeAny(encoder, data))\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nexport const decodeAny = buf => decoding.readAny(decoding.createDecoder(buf))\n\n/**\n * Shift Byte Array {N} bits to the left. Does not expand byte array.\n *\n * @param {Uint8Array} bs\n * @param {number} N should be in the range of [0-7]\n */\nexport const shiftNBitsLeft = (bs, N) => {\n  if (N === 0) return bs\n  bs = new Uint8Array(bs)\n  bs[0] <<= N\n  for (let i = 1; i < bs.length; i++) {\n    bs[i - 1] |= bs[i] >>> (8 - N)\n    bs[i] <<= N\n  }\n  return bs\n}\n","/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as binary from './binary.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as string from './string.js'\nimport * as error from './error.js'\nimport * as encoding from './encoding.js'\n\nconst errorUnexpectedEndOfArray = error.create('Unexpected end of array')\nconst errorIntegerOutOfRange = error.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < binary.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let mult = 64\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & binary.BITS7) * mult\n    mult *= 128\n    if (r < binary.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > number.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nexport const _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nexport const _readVarStringNative = decoder =>\n  /** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nexport const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTerminatedUint8Array = decoder => {\n  const encoder = encoding.createEncoder()\n  let b\n  while (true) {\n    b = readUint8(decoder)\n    if (b === 0) {\n      return encoding.toUint8Array(encoder)\n    }\n    if (b === 1) {\n      b = readUint8(decoder)\n    }\n    encoding.write(encoder, b)\n  }\n}\n\n/**\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const readTerminatedString = decoder => string.decodeUtf8(readTerminatedUint8Array(decoder))\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = math.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n","/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\nimport * as string from './string.js'\nimport * as array from './array.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nexport const encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nexport const hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nexport const verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num = math.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num = math.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, string.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nexport const writeVarString = (string.utf8TextEncoder && /** @type {any} */ (string.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write a string terminated by a special byte sequence. This is not very performant and is\n * generally discouraged. However, the resulting byte arrays are lexiographically ordered which\n * makes this a nice feature for databases.\n *\n * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeTerminatedString = (encoder, str) =>\n  writeTerminatedUint8Array(encoder, string.encodeUtf8(str))\n\n/**\n * Write a terminating Uint8Array. Note that this is not performant and is generally\n * discouraged. There are few situations when this is needed.\n *\n * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.\n *\n * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then\n * the result is terminated using the 0x0 character.\n *\n * This is basically how many systems implement null terminated strings. However, we use an escape\n * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key\n * encoder for NoSql databases).\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} buf The string that is to be encoded.\n */\nexport const writeTerminatedUint8Array = (encoder, buf) => {\n  for (let i = 0; i < buf.length; i++) {\n    const b = buf[i]\n    if (b === 0 || b === 1) {\n      write(encoder, 1)\n    }\n    write(encoder, buf[i])\n  }\n  write(encoder, 0)\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (array.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  /**\n   * Flush the encoded state and transform this to a Uint8Array.\n   *\n   * Note that this should only be called once.\n   */\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n","/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\nimport * as map from './map.js'\nimport * as string from './string.js'\nimport * as conditions from './conditions.js'\nimport * as storage from './storage.js'\nimport * as f from './function.js'\n\n/* c8 ignore next 2 */\n// @ts-ignore\nexport const isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'\n\n/* c8 ignore next */\nexport const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode\n/* c8 ignore next 3 */\nexport const isMac = typeof navigator !== 'undefined'\n  ? /Mac/.test(navigator.platform)\n  : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* c8 ignore start */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create()\n      const pargs = process.argv\n      let currParamName = null\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n      // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create(); // eslint-disable-next-line no-undef\n      (location.search || '?').slice(1).split('&').forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${string.fromCamelCase(key, '-')}`, value)\n          params.set(`-${string.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = map.create()\n    }\n  }\n  return params\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next */\nexport const hasParam = (name) => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* c8 ignore next 2 */\nexport const getParam = (name, defaultVal) =>\n  computeParams().get(name) || defaultVal\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 4 */\nexport const getVariable = (name) =>\n  isNode\n    ? conditions.undefinedToNull(process.env[name.toUpperCase().replaceAll('-', '_')])\n    : conditions.undefinedToNull(storage.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 2 */\nexport const getConf = (name) =>\n  computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {string}\n */\n/* c8 ignore next 5 */\nexport const ensureConf = (name) => {\n  const c = getConf(name)\n  if (c == null) throw new Error(`Expected configuration \"${name.toUpperCase().replaceAll('-', '_')}\"`)\n  return c\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next 2 */\nexport const hasConf = (name) =>\n  hasParam('--' + name) || getVariable(name) !== null\n\n/* c8 ignore next */\nexport const production = hasConf('production')\n\n/* c8 ignore next 2 */\nconst forceColor = isNode &&\n  f.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2'])\n\n/* c8 ignore start */\n/**\n * Color is enabled by default if the terminal supports it.\n *\n * Explicitly enable color using `--color` parameter\n * Disable color using `--no-color` parameter or using `NO_COLOR=1` environment variable.\n * `FORCE_COLOR=1` enables color and takes precedence over all.\n */\nexport const supportsColor = forceColor || (\n  !hasParam('--no-colors') && // @todo deprecate --no-colors\n  !hasConf('no-color') &&\n  (!isNode || process.stdout.isTTY) && (\n    !isNode ||\n    hasParam('--color') ||\n    getVariable('COLORTERM') !== null ||\n    (getVariable('TERM') || '').includes('color')\n  )\n)\n/* c8 ignore stop */\n","/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* c8 ignore next */\nexport const undefinedToNull = v => v === undefined ? null : v\n","/* eslint-env browser */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* c8 ignore start */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\n/* c8 ignore start */\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  if (typeof localStorage !== 'undefined' && localStorage) {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n/* c8 ignore stop */\n\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\n/* c8 ignore next */\nexport const varStorage = _localStorage\n\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nexport const onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n\n/**\n * A polyfill for `removeEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nexport const offChange = eventHandler => usePolyfill || removeEventListener('storage', /** @type {any} */ (eventHandler))\n","/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nexport const create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nexport const unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((array.isArray(a) && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nexport const isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nexport const isArray = array.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nexport const isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nexport const isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nexport const is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nexport const isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n","/**\n * @module sha256\n * Spec: https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\n * Resources:\n * - https://web.archive.org/web/20150315061807/http://csrc.nist.gov/groups/STM/cavp/documents/shs/sha256-384-512.pdf\n */\n\nimport * as binary from '../binary.js'\n\n/**\n * @param {number} w - a 32bit uint\n * @param {number} shift\n */\nconst rotr = (w, shift) => (w >>> shift) | (w << (32 - shift))\n\n/**\n * Helper for SHA-224 & SHA-256. See 4.1.2.\n * @param {number} x\n */\nconst sum0to256 = x => rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22)\n\n/**\n * Helper for SHA-224 & SHA-256. See 4.1.2.\n * @param {number} x\n */\nconst sum1to256 = x => rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25)\n\n/**\n * Helper for SHA-224 & SHA-256. See 4.1.2.\n * @param {number} x\n */\nconst sigma0to256 = x => rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3\n\n/**\n * Helper for SHA-224 & SHA-256. See 4.1.2.\n * @param {number} x\n */\nconst sigma1to256 = x => rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10\n\n// @todo don't init these variables globally\n\n/**\n * See 4.2.2: Constant for sha256 & sha224\n * These words represent the first thirty-two bits of the fractional parts of\n * the cube roots of the first sixty-four prime numbers. In hex, these constant words are (from left to\n * right)\n */\nconst K = new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n])\n\n/**\n * See 5.3.3. Initial hash value.\n *\n * These words were obtained by taking the first thirty-two bits of the fractional parts of the\n * square roots of the first eight prime numbers.\n *\n * @todo shouldn't be a global variable\n */\nconst HINIT = new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n])\n\n// time to beat: (large value < 4.35s)\n\nclass Hasher {\n  constructor () {\n    const buf = new ArrayBuffer(64 + 64 * 4)\n    // Init working variables using a single arraybuffer\n    this._H = new Uint32Array(buf, 0, 8)\n    this._H.set(HINIT)\n    // \"Message schedule\" - a working variable\n    this._W = new Uint32Array(buf, 64, 64)\n  }\n\n  _updateHash () {\n    const H = this._H\n    const W = this._W\n    for (let t = 16; t < 64; t++) {\n      W[t] = sigma1to256(W[t - 2]) + W[t - 7] + sigma0to256(W[t - 15]) + W[t - 16]\n    }\n    let a = H[0]\n    let b = H[1]\n    let c = H[2]\n    let d = H[3]\n    let e = H[4]\n    let f = H[5]\n    let g = H[6]\n    let h = H[7]\n    for (let tt = 0, T1, T2; tt < 64; tt++) {\n      T1 = (h + sum1to256(e) + ((e & f) ^ (~e & g)) + K[tt] + W[tt]) >>> 0\n      T2 = (sum0to256(a) + ((a & b) ^ (a & c) ^ (b & c))) >>> 0\n      h = g\n      g = f\n      f = e\n      e = (d + T1) >>> 0\n      d = c\n      c = b\n      b = a\n      a = (T1 + T2) >>> 0\n    }\n    H[0] += a\n    H[1] += b\n    H[2] += c\n    H[3] += d\n    H[4] += e\n    H[5] += f\n    H[6] += g\n    H[7] += h\n  }\n\n  /**\n   * @param {Uint8Array} data\n   */\n  digest (data) {\n    let i = 0\n    for (; i + 56 <= data.length;) {\n      // write data in big endianess\n      let j = 0\n      for (; j < 16 && i + 3 < data.length; j++) {\n        this._W[j] = data[i++] << 24 | data[i++] << 16 | data[i++] << 8 | data[i++]\n      }\n      if (i % 64 !== 0) { // there is still room to write partial content and the ending bit.\n        this._W.fill(0, j, 16)\n        while (i < data.length) {\n          this._W[j] |= data[i] << ((3 - (i % 4)) * 8)\n          i++\n        }\n        this._W[j] |= binary.BIT8 << ((3 - (i % 4)) * 8)\n      }\n      this._updateHash()\n    }\n    // same check as earlier - the ending bit has been written\n    const isPaddedWith1 = i % 64 !== 0\n    this._W.fill(0, 0, 16)\n    let j = 0\n    for (; i < data.length; j++) {\n      for (let ci = 3; ci >= 0 && i < data.length; ci--) {\n        this._W[j] |= data[i++] << (ci * 8)\n      }\n    }\n    // Write padding of the message. See 5.1.2.\n    if (!isPaddedWith1) {\n      this._W[j - (i % 4 === 0 ? 0 : 1)] |= binary.BIT8 << ((3 - (i % 4)) * 8)\n    }\n    // write length of message (size in bits) as 64 bit uint\n    // @todo test that this works correctly\n    this._W[14] = data.byteLength / binary.BIT30 // same as data.byteLength >>> 30 - but works on floats\n    this._W[15] = data.byteLength * 8\n    this._updateHash()\n    // correct H endianness to use big endiannes and return a Uint8Array\n    const dv = new Uint8Array(32)\n    for (let i = 0; i < this._H.length; i++) {\n      for (let ci = 0; ci < 4; ci++) {\n        dv[i * 4 + ci] = this._H[i] >>> (3 - ci) * 8\n      }\n    }\n    return dv\n  }\n}\n\n/**\n * @param {Uint8Array} data\n */\nexport const digest = data => new Hasher().digest(data)\n","/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nexport const mapIterator = (iterator, f) => ({\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nexport const createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nexport const iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nexport const iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n","/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nexport const create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nexport const isSymbol = s => typeof s === 'symbol'\n","import * as symbol from './symbol.js'\nimport * as time from './time.js'\nimport * as env from './environment.js'\nimport * as func from './function.js'\nimport * as json from './json.js'\n\nexport const BOLD = symbol.create()\nexport const UNBOLD = symbol.create()\nexport const BLUE = symbol.create()\nexport const GREY = symbol.create()\nexport const GREEN = symbol.create()\nexport const RED = symbol.create()\nexport const PURPLE = symbol.create()\nexport const ORANGE = symbol.create()\nexport const UNCOLOR = symbol.create()\n\n/* c8 ignore start */\n/**\n * @param {Array<undefined|string|Symbol|Object|number|function():any>} args\n * @return {Array<string|object|number|undefined>}\n */\nexport const computeNoColorLoggingArgs = args => {\n  if (args.length === 1 && args[0]?.constructor === Function) {\n    args = /** @type {Array<string|Symbol|Object|number>} */ (/** @type {[function]} */ (args)[0]())\n  }\n  const strBuilder = []\n  const logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (arg === undefined) {\n      break\n    } else if (arg.constructor === String || arg.constructor === Number) {\n      strBuilder.push(arg)\n    } else if (arg.constructor === Object) {\n      break\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs.push(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n/* c8 ignore stop */\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = time.getUnixTime()\n\n/* c8 ignore start */\n/**\n * @param {function(...any):void} _print\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nexport const createModuleLogger = (_print, moduleName) => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = env.getVariable('log')\n  const doLogging = debugRegexVar !== null &&\n    (debugRegexVar === '*' || debugRegexVar === 'true' ||\n      new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n  return !doLogging\n    ? func.nop\n    : (...args) => {\n        if (args.length === 1 && args[0]?.constructor === Function) {\n          args = args[0]()\n        }\n        const timeNow = time.getUnixTime()\n        const timeDiff = timeNow - lastLoggingTime\n        lastLoggingTime = timeNow\n        _print(\n          color,\n          moduleName,\n          UNCOLOR,\n          ...args.map((arg) => {\n            if (arg != null && arg.constructor === Uint8Array) {\n              arg = Array.from(arg)\n            }\n            const t = typeof arg\n            switch (t) {\n              case 'string':\n              case 'symbol':\n                return arg\n              default: {\n                return json.stringify(arg)\n              }\n            }\n          }),\n          color,\n          ' +' + timeDiff + 'ms'\n        )\n      }\n}\n/* c8 ignore stop */\n","/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nexport class Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nexport const create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nexport const createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nexport const forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nexport const map = (arr, f) => arr.map(p => f(p.left, p.right))\n","/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\nimport * as pair from './pair.js'\nimport * as map from './map.js'\n\n/* c8 ignore start */\n/**\n * @type {Document}\n */\nexport const doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\nexport const createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\nexport const createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\nexport const createTextNode = text => doc.createTextNode(text)\n\nexport const domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\nexport const emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\nexport const setAttributes = (el, attrs) => {\n  pair.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, '')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\nexport const setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\nexport const fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\nexport const append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\nexport const remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\nexport const addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\nexport const removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\nexport const addEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\nexport const removeEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\nexport const element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\nexport const canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\nexport const text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\nexport const pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\nexport const pairsToStyleString = pairs => pairs.map(pairToStyleString).join('')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\nexport const mapToStyleString = m => map.map(m, (value, key) => `${key}:${value};`).join('')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\nexport const querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\nexport const querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\nexport const getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\nexport const parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\nexport const parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\nexport const replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\nexport const insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\nexport const appendChild = (parent, child) => parent.appendChild(child)\n\nexport const ELEMENT_NODE = doc.ELEMENT_NODE\nexport const TEXT_NODE = doc.TEXT_NODE\nexport const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nexport const COMMENT_NODE = doc.COMMENT_NODE\nexport const DOCUMENT_NODE = doc.DOCUMENT_NODE\nexport const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nexport const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nexport const checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nexport const isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n/* c8 ignore stop */\n","/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\nimport * as env from './environment.js'\nimport * as set from './set.js'\nimport * as pair from './pair.js'\nimport * as dom from './dom.js'\nimport * as json from './json.js'\nimport * as map from './map.js'\nimport * as eventloop from './eventloop.js'\nimport * as math from './math.js'\nimport * as common from './logging.common.js'\n\nexport { BOLD, UNBOLD, BLUE, GREY, GREEN, RED, PURPLE, ORANGE, UNCOLOR } from './logging.common.js'\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [common.BOLD]: pair.create('font-weight', 'bold'),\n  [common.UNBOLD]: pair.create('font-weight', 'normal'),\n  [common.BLUE]: pair.create('color', 'blue'),\n  [common.GREEN]: pair.create('color', 'green'),\n  [common.GREY]: pair.create('color', 'grey'),\n  [common.RED]: pair.create('color', 'red'),\n  [common.PURPLE]: pair.create('color', 'purple'),\n  [common.ORANGE]: pair.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [common.UNCOLOR]: pair.create('color', 'black')\n}\n\n/**\n * @param {Array<string|Symbol|Object|number|function():any>} args\n * @return {Array<string|object|number>}\n */\n/* c8 ignore start */\nconst computeBrowserLoggingArgs = (args) => {\n  if (args.length === 1 && args[0]?.constructor === Function) {\n    args = /** @type {Array<string|Symbol|Object|number>} */ (/** @type {[function]} */ (args)[0]())\n  }\n  const strBuilder = []\n  const styles = []\n  const currentStyle = map.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg === undefined) {\n        break\n      }\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = dom.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n/* c8 ignore stop */\n\n/* c8 ignore start */\nconst computeLoggingArgs = env.supportsColor\n  ? computeBrowserLoggingArgs\n  : common.computeNoColorLoggingArgs\n/* c8 ignore stop */\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.print(args))\n}\n\n/* c8 ignore start */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(common.ORANGE)\n  vconsoles.forEach((vc) => vc.print(args))\n}\n/* c8 ignore stop */\n\n/**\n * @param {Error} err\n */\n/* c8 ignore start */\nexport const printError = (err) => {\n  console.error(err)\n  vconsoles.forEach((vc) => vc.printError(err))\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\n/* c8 ignore start */\nexport const printImg = (url, height) => {\n  if (env.isBrowser) {\n    console.log(\n      '%c                      ',\n      `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`\n    )\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach((vc) => vc.printImg(url, height))\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} base64\n * @param {number} height\n */\n/* c8 ignore next 2 */\nexport const printImgBase64 = (base64, height) =>\n  printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.groupCollapsed(args))\n}\n\nexport const groupEnd = () => {\n  console.groupEnd()\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.groupEnd())\n}\n\n/**\n * @param {function():Node} createNode\n */\n/* c8 ignore next 2 */\nexport const printDom = (createNode) =>\n  vconsoles.forEach((vc) => vc.printDom(createNode()))\n\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\n/* c8 ignore next 2 */\nexport const printCanvas = (canvas, height) =>\n  printImg(canvas.toDataURL(), height)\n\nexport const vconsoles = set.create()\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\n/* c8 ignore start */\nconst _computeLineSpans = (args) => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    let arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg === undefined) {\n        arg = 'undefined '\n      }\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = dom.element('span', [\n          pair.create('style', dom.mapToStyleString(currentStyle))\n        ], [dom.text(arg.toString())])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + json.stringify(content) + ' '\n      }\n      spans.push(\n        dom.element('span', [], [dom.text(/** @type {string} */ (content))])\n      )\n    }\n  }\n  return spans\n}\n/* c8 ignore stop */\n\nconst lineStyle =\n  'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* c8 ignore start */\nexport class VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    eventloop.enqueue(() => {\n      const triangleDown = dom.element('span', [\n        pair.create('hidden', collapsed),\n        pair.create('style', 'color:grey;font-size:120%;')\n      ], [dom.text('')])\n      const triangleRight = dom.element('span', [\n        pair.create('hidden', !collapsed),\n        pair.create('style', 'color:grey;font-size:125%;')\n      ], [dom.text('')])\n      const content = dom.element(\n        'div',\n        [pair.create(\n          'style',\n          `${lineStyle};padding-left:${this.depth * 10}px`\n        )],\n        [triangleDown, triangleRight, dom.text(' ')].concat(\n          _computeLineSpans(args)\n        )\n      )\n      const nextContainer = dom.element('div', [\n        pair.create('hidden', collapsed)\n      ])\n      const nextLine = dom.element('div', [], [content, nextContainer])\n      dom.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      dom.addEventListener(content, 'click', (_event) => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    eventloop.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [\n        dom.element('div', [\n          pair.create(\n            'style',\n            `${lineStyle};padding-left:${this.depth * 10}px`\n          )\n        ], _computeLineSpans(args))\n      ])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([common.RED, common.BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [\n        dom.element('img', [\n          pair.create('src', url),\n          pair.create('height', `${math.round(height * 1.5)}px`)\n        ])\n      ])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    eventloop.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @param {Element} dom\n */\n/* c8 ignore next */\nexport const createVConsole = (dom) => new VConsole(dom)\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nexport const createModuleLogger = (moduleName) => common.createModuleLogger(print, moduleName)\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template K,V\n * @param {Map<K,V>} m\n * @return {Map<K,V>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template {Map<any, any>} MAP\n * @template {MAP extends Map<any,infer V> ? function():V : unknown} CF\n * @param {MAP} map\n * @param {MAP extends Map<infer K,any> ? K : unknown} key\n * @param {CF} createT\n * @return {ReturnType<CF>}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\nexport const HIGHEST_INT32 = binary.BITS31\nexport const HIGHEST_UINT32 = binary.BITS32\n\n/* c8 ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\nexport const parseInt = Number.parseInt\n\n/**\n * Count the number of \"1\" bits in an unsigned 32bit number.\n *\n * Super fun bitcount algorithm by Brian Kernighan.\n *\n * @param {number} n\n */\nexport const countBits = n => {\n  n &= binary.BITS32\n  let count = 0\n  while (n) {\n    n &= (n - 1)\n    count++\n  }\n  return count\n}\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @deprecated use object.size instead\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const size = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|undefined} obj\n */\nexport const isEmpty = obj => {\n  // eslint-disable-next-line\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (size(a) === size(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n * @experimental\n *\n * This is basically a (better typed) duplicate of Observable, which will replace Observable in the\n * next release.\n *\n * @template {{[key in keyof EVENTS]: function(...any):void}} EVENTS\n */\nexport class ObservableV2 {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<string, Set<any>>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)\n    return f\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, /** @type {any} */ (_f))\n      f(...args)\n    }\n    this.on(name, /** @type {any} */ (_f))\n  }\n\n  /**\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name\n   * @param {EVENTS[NAME]} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @template {keyof EVENTS & string} NAME\n   * @param {NAME} name The event name.\n   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n\n/* c8 ignore start */\n/**\n * Handles named events.\n *\n * @deprecated\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n/* c8 ignore end */\n","/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\nimport * as time from './time.js'\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nexport const create = f => /** @type {Promise<T>} */ (new Promise(f))\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nexport const createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template {unknown[] | []} PS\n *\n * @param {PS} ps\n * @return {Promise<{ -readonly [P in keyof PS]: Awaited<PS[P]> }>}\n */\nexport const all = Promise.all.bind(Promise)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nexport const reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nexport const resolve = res => Promise.resolve(res)\n\n/**\n * @template T\n * @param {T} res\n * @return {Promise<T>}\n */\nexport const resolveWith = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n * @deprecated use untilAsync instead\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nexport const until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = time.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* c8 ignore else */\n      if (time.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error('Timeout'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {()=>Promise<boolean>|boolean} check\n * @param {number} timeout\n * @param {number} intervalResolution\n * @return {Promise<void>}\n */\nexport const untilAsync = async (check, timeout = 0, intervalResolution = 10) => {\n  const startTime = time.getUnixTime()\n  const noTimeout = timeout <= 0\n  // eslint-disable-next-line no-unmodified-loop-condition\n  while (noTimeout || time.getUnixTime() - startTime <= timeout) {\n    if (await check()) return\n    await wait(intervalResolution)\n  }\n  throw new Error('Timeout')\n}\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nexport const wait = timeout => create((resolve, _reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nexport const isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n","/* eslint-env browser */\n\nexport const subtle = crypto.subtle\nexport const getRandomValues = crypto.getRandomValues.bind(crypto)\n","/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\nimport { getRandomValues } from 'lib0/webcrypto'\n\nexport const rand = Math.random\n\nexport const uint32 = () => getRandomValues(new Uint32Array(1))[0]\n\nexport const uint53 = () => {\n  const arr = getRandomValues(new Uint32Array(8))\n  return (arr[0] & binary.BITS21) * (binary.BITS32 + 1) + (arr[1] >>> 0)\n}\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nexport const oneOf = arr => arr[math.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\n\n/**\n * @return {string}\n */\nexport const uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set =>\n  set.values().next().value || undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => new Set(entries)\n","import * as array from './array.js'\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * The largest utf16 character.\n * Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)\n */\nexport const MAX_UTF16_CHARACTER = fromCharCode(65535)\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* c8 ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* c8 ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* c8 ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nexport const splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n\n/**\n * @param {string} source\n * @param {number} n\n */\nexport const repeat = (source, n) => array.unfold(n, () => source).join('')\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n"],"names":["last","arr","length","appendTo","dest","src","i","push","from","Array","some","f","isArray","map","mapper","res","BIT1","BIT2","BIT3","BIT4","BIT6","BIT7","BIT8","BIT30","BITS5","BITS6","BITS7","BITS21","BIT22","BITS31","BITS32","createUint8ArrayFromLen","len","Uint8Array","createUint8ArrayViewFromArrayBuffer","buffer","byteOffset","bytes","Buffer","byteLength","toString","s","buf","toHexString","b","padStart","join","copyUint8Array","uint8Array","newBuf","set","errorUnexpectedEndOfArray","errorIntegerOutOfRange","Decoder","constructor","pos","createDecoder","hasContent","decoder","readUint8Array","view","readVarUint8Array","readVarUint","readUint8","num","mult","r","readVarInt","sign","readVarString","decode","remainingLen","encodedString","String","fromCodePoint","nextLen","subarray","apply","decodeURIComponent","escape","readFromDataView","dv","DataView","readAnyLookupTable","undefined","getFloat32","getFloat64","getBigInt64","obj","readAny","RleDecoder","reader","count","read","UintOptRleDecoder","isNegative","IntDiffOptRleDecoder","diff","StringDecoder","str","spos","end","slice","Encoder","cpos","cbuf","bufs","createEncoder","encoder","toUint8Array","uint8arr","curPos","d","verifyLen","bufferLen","write","writeUint8","writeVarUint","writeVarInt","_strBuffer","_maxStrBSize","writeVarString","encodeInto","written","writeVarUint8Array","unescape","encodeURIComponent","codePointAt","writeUint8Array","leftCopyLen","rightCopyLen","writeOnDataView","dview","writeFloat32","setFloat32","writeFloat64","setFloat64","writeBigInt64","setBigInt64","floatTestBed","ArrayBuffer","isFloat32","writeAny","data","keys","Object","key","RleEncoder","writer","w","v","flushUintOptRleEncoder","UintOptRleEncoder","flushIntDiffOptRleEncoder","encodedDiff","IntDiffOptRleEncoder","StringEncoder","sarr","lensE","string","params","undefinedToNull","_localStorage","Map","setItem","newValue","getItem","get","localStorage","e","varStorage","isNode","process","release","test","name","prototype","call","isBrowser","window","document","navigator","platform","args","computeParams","pargs","argv","currParamName","parg","location","search","split","forEach","kv","value","hasParam","has","getVariable","env","toUpperCase","replaceAll","hasConf","supportsColor","forceColor","FORCE_COLOR","stdout","isTTY","includes","create","methodUnimplemented","unexpectedCase","callAll","fs","isOneOf","options","rotr","shift","sum0to256","x","sum1to256","sigma0to256","sigma1to256","K","Uint32Array","HINIT","Hasher","_H","_W","_updateHash","H","W","t","a","c","g","h","tt","T1","T2","digest","j","fill","isPaddedWith1","ci","createIterator","next","Symbol","iterator","iteratorFilter","filter","done","iteratorMap","fmap","BOLD","UNBOLD","BLUE","GREY","GREEN","RED","PURPLE","ORANGE","UNCOLOR","computeNoColorLoggingArgs","Function","strBuilder","logArgs","arg","Number","Pair","left","right","doc","DOMParser","mapToStyleString","m","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","_browserStyleMap","computeLoggingArgs","styles","currentStyle","style","unshift","print","console","log","vconsoles","vc","warn","copy","k","setIfUndefined","createT","any","floor","Math","abs","min","max","isNegativeZero","n","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isInteger","isFinite","parseInt","assign","size","isEmpty","_k","every","hasProperty","hasOwnProperty","equalFlat","val","ObservableV2","_observers","on","add","once","_f","off","observers","delete","emit","values","destroy","Promise","all","bind","crypto","subtle","getRandomValues","uint32","uint53","binary","uuidv4","uuidv4Template","replace","Set","fromCharCode","toLowerCase","trimLeftRegex","trimLeft","fromCamelCaseRegex","fromCamelCase","separator","match","utf8TextEncoder","TextEncoder","encodeUtf8","encode","utf8TextDecoder","TextDecoder","fatal","ignoreBOM","getUnixTime","Date","now"],"sourceRoot":""}